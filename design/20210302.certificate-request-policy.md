---
title: CertificateRequest Policy
authors:
  - "@joshvanl"
reviewers:
  - "@cert-manager-dev"
approvers:
  - "@cert-manager-dev"
editor: "@joshvanl"
creation-date: 2021-03-02
last-updated: 2021-03-09
status: provisional
---

# CertificateRequest Policy

## Table of Contents

<!-- toc -->
- [Summary](#summary)
- [Motivation](#motivation)
- [Goals](#goals)
- [Non-Goals](#non-goals)
- [Proposal](#proposal)
  * [API](#api)
  * [Behaviour](#behaviour)
  * [RBAC](#rbac)
- [External Policy Server](#external-policy-server)
  * [API](#api-1)
  * [gRPC](#grpc)
- [User Stories](#user-stories)
  * [Case 1](#case-1)
  * [Case 2](#case-2)
  * [Case 4](#case-4)
  * [Case 5](#case-5)
  * [Case 6](#case-6)
- [ExternalPolicyServer Example](#externalpolicyserver-example)
<!-- /toc -->

## Summary

Cluster operators will create and manage a set of policy resources that describe
what and how certificates can be signed, as well as RBAC to manage who can
request these certificates. Consumers will be able to request certificates,
restricted by the policy they are bound to.


## Motivation

Policy is an important mechanism for security focused users who would like to
restrict what, who and how certificates are signed in Kubernetes. Currently, the
only mechanism for restriction is either via namespacing (via namespace scoped
Issuer resources) where consumers are bucketed between namespaces, or relying on
policy that is enforced by the signing Issuer.

This greatly limits the amount of restriction that can be imposed by forcing use
of certain Issuers, limited protection through namespaing, and no scope for
users to use external bespoke policy enforcement.


## Goals
- Create first class support for policy over CertificateRequests
- Allow for Policy to be extended to certificates.k8s.io if cert-manager gains adoption of this API
- Implement a mechanism for allowing pluggable extensible policy
- Policy management should have similar user experience to existing Kubernetes
  resources (network policy, PSP replacement)

## Non-Goals
- Apply policy to Certificate resources
- Design external policy engines in this document

---

## Proposal

In order to represent the outcome of policy decisions made by cert-manager,
CertificateRequests will adopt the well-known condition values "approved" and
"denied". These conditions behave the exact same way as the
CertificateSigningRequest, in that CertificateRequest controllers must wait
until the resource has an "approved" condition before continuing processing, or
drop processing entirely if the “denied” condition is present. If the
CertificateRequest has both the "approved" _and_ "denied" condition, even though
this should never happen in practice, the controller must drop processing.


### API

A new resource will be created- CertificateRequestPolicy (cluster scoped).
This resource is designed to be used by cluster operators who want policy based
on security requirements in their organisation, and principle of least
privilege. These cluster operators will bind these policies according to the
requirements of the certificate consumers.

Each field of the policy is effectively taken from the Certificate resource, and
given an “allowed” prefix. Since CertificateRequests are one to one mapped with
Certificate resources and users are familiar with these fields being exposed on
the Certificate resource, this is a logical set of policy options the cluster
operator can configure. Any extension to this base set of rules can be
implemented using an external policy engine.

Apart from verifying external policy servers, fields are validated at admission
time. The status condition is primarily used for exposing the status of the
external policy servers, which are periodically checked.

```go
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:storageversion

// +k8s:openapi-gen=true
type CertificateRequestPolicy struct {
  metav1.TypeMeta   `json:",inline"`
  metav1.ObjectMeta `json:"metadata,omitempty"`

  Spec CertificateRequestPolicySpec `json:"spec"`

  // +optional
  Status CertificateRequestPolicyStatus `json:"status"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type CertificateRequestPolicyList struct {
  metav1.TypeMeta `json:",inline"`
  metav1.ListMeta `json:"metadata"`

  Items []CertificateRequestPolicy `json:"items"`
}

type CertificateRequestPolicySpec struct {
  // +optional
  AllowedSubject *PolicyX509Subject `json:"allowedSubject,omitempty"`

  // +optional
  AllowedCommonName *string `json:"subject,omitempty"`

  // Values are inclusive (i.e. a min value with 50s will accept a duration
  // with 50s). MinDuration and MaxDuration may be the same.
  // +optional
  MinDuration *metav1.Duration `json:"minDuration,omitempty"`
  // +optional
  MaxDuration *metav1.Duration `json:"maxDuration,omitempty"`

  // +optional
  AllowedDNSNames *[]string `json:"allowedDNSNames,omitempty"`

  // +optional
  AllowedIPAddresses *[]string `json:"allowedIPAddresses,omitempty"`

  // +optional
  AllowedURIs *[]string `json:"allowedURIs,omitempty"`

  // +optional
  AllowedEmailAddresses *[]string `json:"allowedEmailAddresses,omitempty"`

  // +optional
  AllowedIssuers *[]cmmeta.ObjectReference `json:"allowedIssuer,omitempty"`

  // +optional
  AllowedIsCA *bool `json:"allowedIsCA,omitempty"`

  // +optional
  AllowedUsages *[]cmapi.KeyUsage `json:"allowedUsages,omitempty"`

  // +optional
  AllowedPrivateKey *PolicyPrivateKey `json:"allowedPrivateKey,omitempty"`

  // +optional
  ExternalPolicyServers []string `json:"externalPolicyServers,omitempty"`
}

type PolicyX509Subject struct {
  // +optional
  AllowedOrganizations *[]string `json:"allowedOrganizations,omitempty"`
  // +optional
  AllowedCountries *[]string `json:"allowedCountries,omitempty"`
  // +optional
  AllowedOrganizationalUnits *[]string `json:"allowedOrganizationalUnits,omitempty"`
  // +optional
  AllowedLocalities *[]string `json:"allowedLocalities,omitempty"`
  // +optional
  AllowedProvinces *[]string `json:"allowedProvinces,omitempty"`
  // +optional
  AllowedStreetAddresses *[]string `json:"allowedStreetAddresses,omitempty"`
  // +optional
  AllowedPostalCodes *[]string `json:"allowedPostalCodes,omitempty"`
  // +optional
  AllowedSerialNumber *string `json:"allowedSerialNumber,omitempty"`
}

type PolicyPrivateKey struct {
  // +optional
  AllowedAlgorithm *cmapi.PrivateKeyAlgorithm `json:"allowedAlgorithm,omitempty"`

  // Values are inclusive (i.e. a min value with 2048 will accept a size of
  // 2048). MinSize and MaxSize may be the same.
  // +optional
  MinSize *int `json:"allowedMinSize,omitempty"`
  // +optional
  MaxSize *int `json:"allowedMaxSize,omitempty"`
}

type CertificateRequestPolicyStatus struct {
  // +optional
  Conditions []CertificateRequestPolicyCondition `json:"conditions,omitempty"`
}

type CertificateRequestPolicyCondition struct {
  Type   CertificateRequestPolicyConditionType `json:"type"`
  Status cmmeta.ConditionStatus                `json:"status"`

  // +optional
  LastTransitionTime *metav1.Time `json:"lastTransitionTime,omitempty"`

  // +optional
  Reason string `json:"reason,omitempty"`

  // +optional
  Message string `json:"message,omitempty"`

  ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

type CertificateRequestPolicyConditionType string

const (
  CertificateRequestPolicyConditionReady CertificateRequestPolicyConditionType = "Ready"
)
```

Each non-enum string value can match using glob. This means that "*.example.com"
can match with "foo.example.com", but not "example.com". We may decide that we
would rather use regex, which would allow the user to express things _not_
allowed ('^'), however regex can be complicated to write and is prone to errors
(escaping full stops etc.).

An empty or nil field can be considered as being "allow all" for that field.

### Behaviour

In order to keep backwards compatibility, and be in-line with the behaviour of
existing resources such as network policies, the default action will be to
"allow all" if no policy resource exists. As soon as a resource exists,
cert-manager will "deny all" unless the CertificateRequest is accepted by the
existing policy.

The cert-manager CertificateRequest policy controller will watch
CertificateRequest resources, which when they are created, will evaluate whether
they pass approval. This is done by checking that a CertificateRequestPolicy
which approves this request is [bound](#rbac) to the user who appears in the
user info field of the request. If *any* CertificateRequestPolicy succeeds, the
CertificateRequest is marked as *approved*. If *no* CertificateRequestPolicy
succeeds, the CertificateRequest is marked as *denied*.

### RBAC


The binding of CertificateRequestPolicy and CertificateRequests is achieved
using RBAC. This offers two dimensions to how the policy can be applied-
namespace and user. A policy can be bound to an entire namespace regardless of
user (system:authenticated), bound to particular users, or a mixture of both.

When the policy controller evaluates whether a particular policy should be
checked against a CertificateRequest, it will perform a SubjectAccessReview
against the user present on the CertificateRequest. Since the
CertificateRequestPolicy can be bound by both namespace and cluster scope, the
SubjectAccessReview will be requested for both the namespace the
CertificateRequest resides in, as well as at the cluster scope. The namespace
scope will be checked first in an effort to improve performance (a large number
of CertificateRequestPolicy resources are likely scoped by namespace). The
SubjectAccessReview will be requested for every single CertificateRequestPolicy
that exists, until and if a CertificateRequestPolicy which is bound approves the
request. If no CertificateRequestPolicy approves the request, the
CertificateRequest is marked as denied.

The SubjectAccessReview will request for the attributes:

```yaml
Group: policy.cert-manager.io
Verb: use
Resource: CertificateRequestPolicy
Name: <Name of the CertificateRequestPolicy being checked>
Namespace: <Namespace of the CertificateRequest, empty if checking cluster scope>
```

---

## External Policy Server

To allow for third parties to implement extensions to policy that the core
functionality does not provide, the CertificateRequestPolicy resource can list
ExternalPolicyServers. An ExternalPolicyServer resource represents a single
policy engine server that can receive policy checks, evaluate the request, and
then respond as to whether the request is approved, not-approved, or in an error
state.


For each ExternalPolicyServer listed in the CertificateRequestPolicy, the policy
controller will request from each server, where any not-approved request will
make the entire CertificateRequestPolicy as not-approved. All
ExternalPolicyServer may be called in turn, or perhaps concurrently to improve
performance. Connections will be made to the ExternalPolicyServers using gRPC.
This connection is secured using TLS, where the server's CA certificate is
discovered by the ExternalPolicyServer resource.


If the call to the ExternalPolicyServer fails to return a result (network error,
incorrect CA, server not ready), then the CertificateRequestPolicy will return a
pending state. The policy controller will retry this CertificateRequestPolicy
for the same request at a later time if no other CertificateRequestPolicys
exist, they deny the request, or also return a pending state (i.e. no other
CertificateRequestPolicys approve the request).

We may want to introduce a 4th response type "defer" to capture the idea that
the ExternalPolicyServer does not handle the request given and cant compute it.
This is functionality equivalent to "approve", however bubbles up the intent
better to statuses.

### API


The following is the resource definition of the ExternalPolicyServer (cluster scoped).

```go
type ExternalPolicyServer struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`

    Spec ExternalPolicyServerSpec `json:"spec"`

    // +optional
    Status ExternalPolicyServerStatus `json:"status"`
}

type ExternalPolicyServerList struct {
    metav1.TypeMeta `json:",inline"`
    metav1.ListMeta `json:"metadata"`

    Items []ExternalPolicyServer `json:"items"`
}

type ExternalPolicyServerSpec struct {
    Endpoint string `json:"endpoint"`

    // +optional
    CABundle *CABundle `json:"caBundle,omitempty"`
}

type CABundle struct {
    // +optional
    Data         *[]byte `json:"data,omitempty"`

    // +optional
    ConfigMapRef *cmmeta.ObjectReference `json:"configMapRef,omitempty"`

    // +optional
    SecretRef *cmmeta.ObjectReference `json:"secretRef,omitempty"`
}

type ExternalPolicyServerStatus struct {
    // +optional
	  Conditions []ExternalPolicyServerCondition `json:"conditions,omitempty"`
}

type ExternalPolicyServerCondition struct {
    Type ExternalPolicyServerConditionType `json:"type"`
    Status cmmeta.ConditionStatus `json:"status"`

    // +optional
    LastTransitionTime *metav1.Time `json:"lastTransitionTime,omitempty"`

    // +optional
    Reason string `json:"reason,omitempty"`

    // +optional
    Message string `json:"message,omitempty"`
    ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

type ExternalPolicyServerConditionType string

const (
    ExternalPolicyServerConditionReady ExternalPolicyServerConditionType = "Ready"
)
```

The non-optional endpoint field denotes the remote address that the webhook will
connect to to evaluate the CertificateRequest.


The CA bundle field must contain exactly one of either the raw CA bundle PEM
data, a configmap, or secret reference to where the CA PEM data exists. The
CA bundle _may_ be empty, however any CertificateRequestPolicy which references
this ExternalPolicyServer will not evaluate the CertificateRequest, and requeue
until a CA is present.

The raw CA bundle may be populated using the same annotations fields managed by
the ca-injector, namely:

- cert-manager.io/inject-ca-from
- cert-manager.io/inject-ca-from-secret
- cert-manager.io/inject-apiserver-ca

These annotations behave the exact same as the current admission webhook
equivalents.

### gRPC


The following protobuf API will be used when sending and receiving messages to
the external policy servers. A reason message is returned to be bubbled to the
user.

```protobuf
message PolicyRequest {
  // <Protobuf for k8s metadata fields>
  // <Request Field>
  // <IssuerRef Field>
  // <IsCA Field>
  // <Duration Field>
  // <Usages Field>
  // <User Info Fields>
}

message  PolicyResponse {
  enum Result {
    APPROVED = 0;
    DENIED = 1;
    ERROR = 2;
  }
  Result result = 1;

  string reason = 2;
}
```

Error responses from the ExternalPolicyServer should result in the
CertificateRequestPolicy retrying the request at a later time, if the request is
not approved by another CertificateRequestPolicy.

---

## User Stories

Below is a collection of user stories which are satisfied using the system
describe in this design.


### Case 1

*Use a single issuer but only make it available to a subset of namespaces, and
don't want to deploy a namespaced issuer to each of those namespaces.*

Create a RoleBinding to each namespace to a role which includes an allow-all
CertificateRequestPolicy.

```yaml
apiVersion: policy.cert-manager/v1alpha1
kind: CertificateRequestPolicy
metadata:
  name: allow-all
spec:
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cert-manager-policy-allow-all
  namespace: foo
rules:
  - apiGroups: ["policy.cert-manager.io"]
    resources: ["certificaterequestpolicy"]
    verbs: ["use"]
    resourceNames: ["allow-all"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cert-manager-policy-allow-all
  namespace: foo-bar
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cert-manager-policy-allow-all
subjects:
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
```


### Case 2

*Control which k8s identities can issue certs for particular domains.*

Create a CertificateRequestPolicy for each domain required, and bind these
using RBAC to those particular identity. Alternatively, create an external
policy server which maps these identities to domains bespoke, and bind a
single CertificateRequestPolicy to everyone that includes this server.

```yaml
apiVersion: policy.cert-manager/v1alpha1
kind: CertificateRequestPolicy
metadata:
  name: domain-specific
spec:
  allowedDNSNames:
  - example.com
  - foo.bar.co.uk
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cert-manager-certificaterequestpolicy-domain-specific
rules:
  - apiGroups: ["policy.cert-manager.io"]
    resources: ["certificaterequestpolicy"]
    verbs: ["use"]
    resourceNames: ["domain-specific"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cert-manager-certificaterequestpolicy-domain-specific
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-certificaterequestpolicy-domain-specific
subjects:
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
```

### Case 4

*Harden istio CA with istio-csr; Have a policy that will restrict only
istio-csr can create certs in the istio-system namespace, and these
certificates only contain subjects with the service names only, no other
subject*

Create a CertificateRequestPolicy which is bound to the istio-csr service
account in the istio-system namespace. This policy will enforce that only the
URI names may be present.

```yaml
apiVersion: policy.cert-manager/v1alpha1
kind: ExternalPolicyServer
metadata:
  name: istio-csr
spec:
  endpoint: cert-manager-istio-csr-policy.cert-manager
  caBundle:
    configMapRef:
      name: cert-manager-istio-csr-policy-tls
      key: ca.tls
---
apiVersion: policy.cert-manager/v1alpha1
kind: CertificateRequestPolicy
metadata:
  name: allow-all
spec:
  allowedCommonName: ""
  allowedDNSNames: []
  allowedIPAddresses: []
  allowedURIs: "*.svc.<trust domain>"
  allowedIssuers:
  - name: istio-ca
    type: Issuer
    group: cert-manager.io
  externalPolicyServers:
  - istio-csr
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cert-manager-istio-csr:cert-manager-certificaterequestpolicy
  namespace: istio-system
rules:
  - apiGroups: ["policy.cert-manager.io"]
    resources: ["certificaterequestpolicy"]
    verbs: ["use"]
    resourceNames: ["cert-manager-istio-csr"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cert-manager-istio-csr:cert-manager-certificaterequestpolicy
  namespace: istio-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cert-manager-istio-csr
subjects:
- kind: ServiceAccount
  name: cert-manager-istio-csr
  namespace: istio-system
```

Another step would be to create an external policy server that would validate
that the spiffe ID matches that of the user info field on the
CertificateRequest.


### Case 5

*Harden CSI driver to allow auto SPIFFE certs*

Create an external policy server to enforce SPIFFE certificates based on the
user info fields.

```yaml
apiVersion: policy.cert-manager/v1alpha1
kind: ExternalPolicyServer
metadata:
  name: spiffe
  annotations:
    cert-manager.io/inject-ca-from: spiffe-policy
spec:
  endpoint: cert-manager-spiffe-policy.cert-manager
  caBundle:
    # Populated from spiffe-policy Certificate by ca-injector
    data: foobar
---
apiVersion: policy.cert-manager/v1alpha1
kind: CertificateRequestPolicy
metadata:
  name: csi-spiffe
spec:
  allowedURIs: "*.svc.cluster-1"
  allowedDNSNames: []
  allowedIPAddresses: []
  allowedIssuers:
  - name: spiffe
    type: ClusterIssuer
    group: cert-manager.io
  externalPolicyServers:
  - spiffe
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csi-spiffe
rules:
  - apiGroups: ["policy.cert-manager.io"]
    resources: ["certificaterequestpolicy"]
    verbs: ["use"]
    resourceNames: ["csi-spiffe"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: csi-spiffe
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: csi-spiffe
subjects:
- kind: Group
  name: system:authenticated
  apiGroup: rbac.authorization.k8s.io
```

### Case 6

*Manual approval of certificates*

Create an external policy server that repeatedly returns an error response to
requests, _unless_ that CertificateRequest is given a condition with a
well-known type that this policy server observes. Once this condition is
present, return an approved response. Since an update to the status condition
will cause an immediate re-sync, the policy check will be immediately
re-evaluated and the external policy server will approve.

A helper kubectl plugin CLI can be created to make approving certificates easier
for certificate administrators.

```yaml
apiVersion: policy.cert-manager/v1alpha1
kind: ExternalPolicyServer
metadata:
  name: manual
spec:
  endpoint: manual-approval-policy.cert-manager
  secretRef:
    name: manual-approval-tls
    key: ca.tls
---
apiVersion: policy.cert-manager/v1alpha1
kind: CertificateRequestPolicy
metadata:
  name: manual-approval
spec:
  allowedDNSNames: ["example.com", "*.example.com"]
  allowedURIs: []
  allowedIPAddresses: []
  externalPolicyServers:
  - manual
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cert-manager-certificaterequestpolicy:manual-approval
rules:
  - apiGroups: ["policy.cert-manager.io"]
    resources: ["certificaterequestpolicy"]
    verbs: ["use"]
    resourceNames: ["manual-approval"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cert-manager-certificaterequestpolicy:manual-approval
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cert-manager-certificaterequestpolicy:manual-approval
subjects:
- kind: Group
  name: system:authenticated
  apiGroup: rbac.authorization.k8s.io
```

```bash
kubectl manual-approve foo -n bar
```

## ExternalPolicyServer Example

The External Policy Server API may be used for implementing a custom policy
server.  Using the External Policy Server API for that purpose looks like:

```yaml
kind: Deployment
metadata:
  name: custom-policy-engine
  namespace: custom-policy
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: custom-policy-engine
  template:
    metadata:
      labels:
        app.kubernetes.io/name: custom-policy-engine
    spec:
      containers:
      - name: custom-policy-engine
        image: custom-policy-engine:0.1.0
        ports:
        - containerPort: 8080
---
kind: Service
metadata:
  name: custom-policy-engine
  namespace: custom-policy
spec:
  type: ClusterIP
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
  selector:
    app.kubernetes.io/name: custom-policy-engine
---
kind: ExternalPolicyServer
metadata:
  name: opa-shim
spec:
  endpoint: https://custom-policy-engine.custom-policy:8080
  # The caBundle may be populated either by referecing a ConfigMap/Secret, or
  # adding ca-injector annotations to this object
  caBundle:                  # optional
    data: |                  # optional
      base64-encoded-pem-file
    configMapRef:            # optional
      name: opa-shim-config
    secretRef:               # optional
      name: opa-shim-tls
status:
  conditions:
  - type: Ready
    status: "True"
    lastTransitionTime: "2021-02-18T06:53:01Z"
    reason: "OpaShimReady"
    message: "opa-shim is ready"
    observedGeneration: 42
```

We aim at making it easy to plug an existing policy engine, such as OPA, using a shim
server that would do the translation work between the External Policy Server API and
the OPA API. The shim, probably a Go binary running as a Deployment, would expose
the `https://opa-shim:8080` endpoint (for example).

```yaml
kind: ExternalPolicyServer
metadata:
  name: opa-shim
spec:
  endpoint: https://opa-shim:8080
  # The caBundle may be populated either by referecing a ConfigMap/Secret, or
  # adding ca-injector annotations to this object
  caBundle:
    data: |
      base64-encoded-pem-file
    configMapRef:
      name: opa-shim-config
    secretRef:
      name: opa-shim-tls
status:
  conditions:
  - type: Ready
    status: "True"
    lastTransitionTime: "2021-02-18T06:53:01Z"
    reason: "OpaShimReady"
    message: "opa-shim is ready"
    observedGeneration: 42
```
